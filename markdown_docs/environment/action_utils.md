## FunctionDef bits_between(number, start, end)
**bits_between**: The function of bits_between is to extract and return a specified range of bits from a given integer number.
**parameters**: The parameters of this Function.
· number: an integer from which the bits will be extracted
· start: the starting position of the bit range to be extracted
· end: the ending position of the bit range to be extracted
**Code Description**: This function takes an integer number and extracts a specified range of bits, defined by the start and end positions. It uses bitwise operations to achieve this, specifically the left shift operator to create masks for the extraction process. The result is then returned as an integer. In the context of the project, this function is used by other functions such as action_breakdown, is_waive, and ordered_province to extract specific bits from action integers, which represent various components of an action like order, province IDs, and coast indicators.
**Note**: The start position is inclusive, while the end position is exclusive. This means that the bit at the start position will be included in the extracted range, but the bit at the end position will not. Also, the function assumes that the start position is less than or equal to the end position and that both positions are non-negative.
**Output Example**: If you call bits_between(0b11010110, 2, 5), the function will return the integer value of the bits between positions 2 and 5 (exclusive) from the binary representation of the input number, which is 0b101. The decimal equivalent of this would be 5.
## FunctionDef actions_for_province(legal_actions, province)
**actions_for_province**: The function of actions_for_province is to filter a list of legal actions and return only those where the main unit is located in a specified province.
**parameters**: The parameters of this Function.
· legal_actions: a sequence of actions to be filtered, where each action is of type Action
· province: the ID of the province to filter by, which should match the ProvinceID type defined in the utils module
**Code Description**: This function iterates over each action in the provided list of legal actions. For each action, it calls the ordered_province function to determine the province associated with that action. If the determined province matches the specified province, the action is added to the result list. The function ultimately returns this filtered list of actions. The relationship between actions_for_province and ordered_province is crucial, as the latter provides the necessary information about the province associated with each action, allowing actions_for_province to perform its filtering operation effectively.
**Note**: It's essential to ensure that the input parameters are of the correct type and that the province ID is valid within the context of the project. Additionally, the function assumes that the ordered_province function behaves as expected and returns a ProvinceID or an array of province IDs based on the input action.
**Output Example**: If the input list of legal actions contains three actions with provinces A, B, and A respectively, and the specified province is A, the function would return a list containing only the first and third actions, since their main units are located in province A. The returned list might look like [Action1, Action3], where Action1 and Action3 represent the actual action objects that match the specified province.
## FunctionDef construct_action(order, ordering_province, target_province, third_province)
**construct_action**: The function of construct_action is to create an action representation based on the given order and province information.
**parameters**: The parameters of this Function.
· order: An Order object that determines the type of action to be constructed.
· ordering_province: A utils.ProvinceWithFlag object representing the province that is giving the order, or None if not applicable.
· target_province: A utils.ProvinceWithFlag object representing the target province of the action, or None if not applicable.
· third_province: A utils.ProvinceWithFlag object representing a third province involved in the action, or None if not applicable.
**Code Description**: The construct_action function takes an order and up to three provinces as input and returns a compact representation of the action. It starts by initializing an order representation variable to 0. Then, it shifts the order value to its designated position in the representation using the ACTION_ORDER_START constant. If an ordering province is provided, its value is shifted to the ACTION_ORDERED_PROVINCE_START position. For build fleet orders, the coast information of the ordering province is also included by shifting its value to the ACTION_ORDERED_PROVINCE_COAST position. Similarly, if a target province and/or a third province are provided, their values are shifted to the corresponding positions in the representation. The function returns the constructed action representation.
**Note**: The function assumes that the input provinces are valid and that the order is one of the supported types. It also relies on the constants ACTION_ORDER_START, ACTION_ORDERED_PROVINCE_START, ACTION_TARGET_PROVINCE_START, ACTION_THIRD_PROVINCE_START, ACTION_ORDERED_PROVINCE_COAST, and ACTION_TARGET_PROVINCE_COAST being defined elsewhere in the codebase.
**Output Example**: The return value of construct_action could be an integer representing the compact action representation, such as 0x12345678, where each part of the integer corresponds to a specific aspect of the action (e.g., order type, ordering province, target province, etc.).
## FunctionDef action_breakdown(action)
**action_breakdown**: The function of action_breakdown is to break down an action into its component parts, including order and province information.
**parameters**: The parameters of this Function.
· action: a 32bit or 64bit integer action that needs to be broken down into its components.
**Code Description**: This function takes an action as input and extracts specific bits from it using the bits_between function. It first extracts the order, which is an integer between 1 and 13, by calling bits_between with the action and the start and end positions of the order bits. Then, it extracts three sets of province information, each consisting of a province ID and a coast indicator bit, by calling bits_between with the action and the start and end positions of the corresponding province bits. The extracted information is then returned as a tuple containing the order and the three sets of province information.
The function relies on the bits_between function to extract specific bits from the action integer, which represents various components of an action like order, province IDs, and coast indicators. The bits_between function uses bitwise operations to achieve this, specifically the left shift operator to create masks for the extraction process.
**Note**: The coast indicator bits returned by this function are not area_ids as returned by other functions, but rather a specific type of bit that indicates the coast of a province. Also, the start position is inclusive, while the end position is exclusive, meaning that the bit at the start position will be included in the extracted range, but the bit at the end position will not.
**Output Example**: If you call action_breakdown with a valid action integer, the function will return a tuple containing an integer order and three tuples of province information, each consisting of a province ID and a coast indicator bit. For example, the output might look like (5, (10, 1), (20, 0), (30, 1)), where 5 is the order, and (10, 1), (20, 0), and (30, 1) are the three sets of province information.
## FunctionDef action_index(action)
**action_index**: The function of action_index is to return the actions index among all possible unit actions.
**parameters**: The parameters of this Function.
· action: This parameter can be either an Action or a numpy array (np.ndarray), which represents the input action to be processed.
**Code Description**: The action_index function takes an action as input and returns its corresponding index. The calculation is performed using a bitwise right shift operation (>>), where the action is shifted by ACTION_INDEX_START bits. This suggests that ACTION_INDEX_START is a predefined constant that determines the starting point for the indexing. The result of this operation is then returned as either an integer or a numpy array, depending on the input type.
**Note**: It is essential to ensure that the input action is valid and compatible with the ACTION_INDEX_START constant to obtain accurate results. Additionally, understanding the context and definition of ACTION_INDEX_START is crucial for correctly interpreting the output of this function.
**Output Example**: The return value could be an integer, such as 5, or a numpy array, like np.array([1, 2, 3]), depending on the input action and the value of ACTION_INDEX_START. For instance, if the input action is an Action object that corresponds to the index 5, the function might return the integer 5. If the input is a numpy array representing multiple actions, the function could return a numpy array containing their respective indices.
## FunctionDef is_waive(action)
**is_waive**: The function of is_waive is to determine whether a given action represents a waive order.
**parameters**: The parameters of this Function.
· action: an action object that can be either of type Action or ActionNoIndex, which contains information about the action to be evaluated.
**Code Description**: This function works by extracting a specific range of bits from the given action using the bits_between function. The extracted bits represent the order of the action, which is then compared to the WAIVE value. If the extracted order matches the WAIVE value, the function returns True, indicating that the action represents a waive order. Otherwise, it returns False. The bits_between function takes three parameters: the number from which to extract bits, and the start and end positions of the bit range to be extracted. In this case, the start position is ACTION_ORDER_START, and the end position is ACTION_ORDER_START plus ACTION_ORDER_BITS. This suggests that the order information is encoded in a specific range of bits within the action object.
**Note**: The function assumes that the action object contains valid information about the order, and that the WAIVE value is correctly defined. Additionally, the function relies on the correct implementation of the bits_between function to extract the relevant bits from the action object. It is also important to note that the start position is inclusive, while the end position is exclusive, as defined in the bits_between function.
**Output Example**: If the given action represents a waive order, the function will return True, otherwise it will return False. For example, if the action object contains the value 0b11010110, and the WAIVE value is 5, and the ACTION_ORDER_START is 2, and the ACTION_ORDER_BITS is 3, the function will extract the bits between positions 2 and 5 (exclusive) from the binary representation of the input number, which is 0b101, and compare it to the WAIVE value. If they match, the function will return True, indicating that the action represents a waive order.
## FunctionDef ordered_province(action)
**ordered_province**: The function of ordered_province is to extract and return the province ID from a given action.
**parameters**: The parameters of this Function.
· action: an action from which the province ID will be extracted, which can be of type Action, ActionNoIndex, or np.ndarray
**Code Description**: This function takes an action as input and uses the bits_between function to extract a specified range of bits from the action. The start position of the bit range is defined by ACTION_ORDERED_PROVINCE_START, and the end position is ACTION_ORDERED_PROVINCE_START plus ACTION_PROVINCE_BITS. The extracted bits are then returned as the province ID, which can be either a single ProvinceID or an array of province IDs if the input action is an np.ndarray. In the context of the project, this function is used by other functions such as actions_for_province and find_action_with_area to determine the province associated with a given action.
**Note**: The bits_between function assumes that the start position is less than or equal to the end position and that both positions are non-negative. Additionally, the function uses bitwise operations to extract the specified range of bits from the input action.
**Output Example**: If the input action has a binary representation of 0b11010110, and ACTION_ORDERED_PROVINCE_START is 2 and ACTION_PROVINCE_BITS is 3, the function will return the integer value of the bits between positions 2 and 5 (exclusive) from the binary representation of the input action, which could represent a specific province ID.
## FunctionDef shrink_actions(actions)
**shrink_actions**: The function of shrink_actions is to retain the top and bottom byte pairs of actions, effectively "shrinking" them while preserving key information such as index, order, and area.

**parameters**: The parameters of this Function.
· actions: a single action or a sequence of actions, which can be provided as an Action object, a Sequence of Action objects, or a numpy array, representing the input actions to be shrunk.

**Code Description**: This function takes in actions, which are first converted into a numpy array for uniform processing. If the input array is empty, it simply returns the empty array cast to int32 type. For non-empty arrays, it applies bitwise operations to extract and combine the top and bottom byte pairs of each action. Specifically, it shifts the bits of each action 32 places to the right, masks out all but the top 16 bits (using ~0xffff), then adds this result to the bottom 16 bits of the original action (obtained by masking with & 0xffff). The outcome is a new array where each action has been "shrunk" according to these rules, preserving key information in the top and bottom byte pairs. This process is performed using numpy's vectorized operations, ensuring efficiency even for large inputs.

**Note**: It's crucial to understand that this function assumes a specific format of the input actions, as described at the top of the file where this function is defined. The bitwise operations are tailored to extract meaningful information from actions structured in this particular way. Users should ensure their actions conform to this expected format to achieve the desired outcome.

**Output Example**: The return value will be a numpy array of type int32, where each element represents a shrunk action. For instance, if an input action is represented by a 64-bit integer, the output might look like an array of integers where each integer corresponds to the top and bottom byte pairs of the original actions, such as np.array([0x0000ffff, 0x1234abcd], dtype=np.int32). The exact values depend on the input actions and their specific binary representations.
## FunctionDef find_action_with_area(actions, area)
**find_action_with_area**: The function of find_action_with_area is to retrieve the first action in a list that corresponds to a unit in a specified area, returning 0 if no such action exists.
**parameters**: The parameters of this Function.
· actions: a sequence of actions, where each action can be either an Action or an ActionNoIndex object
· area: an AreaID object representing the area for which the action is being searched
**Code Description**: This function iterates through the list of provided actions to find the first one that matches the specified area. It does this by first extracting the province ID from the given area using the utils.province_id_and_area_index function, which returns a tuple containing the province ID and an area index. The function then uses the ordered_province function to extract the province ID from each action in the list and compares it with the extracted province ID from the area. If a match is found, the function immediately returns the matching action. If no match is found after iterating through all actions, the function returns 0.
**Note**: The function relies on the ordered_province function to correctly extract the province ID from each action, and the utils.province_id_and_area_index function to accurately determine the province ID from the given area. Additionally, the function assumes that the list of actions is not empty and that the area is a valid AreaID object.
**Output Example**: If the input list of actions contains an action that corresponds to the specified area, the function may return an Action or ActionNoIndex object representing that action, such as an integer value representing the action. For instance, if the input list contains an action with a province ID matching the area's province ID, the function could return that action, e.g., 12345. If no matching action is found, the function returns 0.
